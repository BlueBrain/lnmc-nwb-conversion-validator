"""Report generator.

Copyright 2024 Blue Brain Project / EPFL

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import pathlib
from pylatex import (
    Document,
    Section,
    Subsection,
    Command,
    Itemize,
)
from pylatex.utils import NoEscape, verbatim, bold
from nwb_data_validator.version import __version__
from nwb_data_validator.validators import NWBValidator, DatasetValidator
from nwb_data_validator import utils


class AsciiReport:
    """A text-based report class."""

    def __init__(self, experimenter_name, validation_results):
        """Constructor.

        Args:
        experimenter_name (str): initials of the experimenter name in capital letters.
        validation_results (dict): nested dictionary of the validation results.
        """
        self.experimenter_name = experimenter_name
        self.validation_results = validation_results
        self.readable_results = self.parse_dict()

    def parse_dict(self):
        """Parse the validation_results dict into the output format."""
        return utils.flatten_nested_keys_of_failed_tests(self.validation_results)

    def to_txt(self, output_path="."):
        """Prints the report to a text file at the output_path."""
        cwd = pathlib.Path.cwd()
        txt_output = cwd / output_path / f"{self.experimenter_name}_report.txt"

        with open(txt_output, "w", encoding="utf-8") as f_handle:
            f_handle.write(f"Validation report for {self.experimenter_name}.\n")
            for line in self.readable_results:
                f_handle.write(f"{line}\n")
            f_handle.write("Report is created successfully.\n")


class LatexReport(Document):
    """Latex Report generator class that inherits pylatex's Document class."""

    def __init__(self, experimenter_name):
        """Constructor.

        experimenter_name (str): The name of the experiment.
        """
        super().__init__(font_size="small")

        self.preamble.append(
            Command(
                "title", f"QA & QC report for the {experimenter_name} data conversion"
            )
        )
        self.preamble.append(
            Command("author", f"Generated by NWB Data Validator {__version__}")
        )
        self.preamble.append(Command("date", NoEscape(r"\today")))
        self.append(NoEscape(r"\maketitle"))

    def fill_criteria_description(self):
        """Fills the document with the QA & QC criteria."""
        with self.create(Section("Criteria")):
            description = (
                "This report describes the Quality assurance (QA) "
                "and quality control (QC) of the IGOR binary wave format to NWB"
                "(Neurodata Without Borders) data conversion. "
                "The report contains only the validation & verification "
                "failures for the NWB files in the batch."
            )
            self.append(description)
            self.append("\n The source code is available on \n")
            self.append(
                verbatim("https://github.com/BlueBrain/lnmc-nwb-conversion-validator")
            )
            with self.create(Subsection("NWB Metadata")):
                self.append("The list of NWB metadata to be verified are as follows.")
                for metadata in NWBValidator.required_metadata:
                    with self.create(Itemize()) as itemize:
                        itemize.add_item(metadata)

            with self.create(Subsection("Acquisition and Stimuli Metadata")):
                self.append(
                    "The list of metadata to be verified "
                    "for an acquisition or stimulus are as follows."
                )
                self.append(
                    """Note: wavenotes_present is False if and only if the """
                    """nwb wavenotes are missing while the igor wavenote is present."""
                )
                for metadata in DatasetValidator.metadata_for_verification:
                    with self.create(Itemize()) as itemize:
                        itemize.add_item(metadata)
                self.append(
                    "The list of metadata to be validated "
                    "for an acquisition or stimulus are as follows."
                )
                for metadata in DatasetValidator.metadata_for_validation:
                    with self.create(Itemize()) as itemize:
                        itemize.add_item(metadata)
                self.append(
                    "There are also additional tests to help the NMC team "
                    "with the data conversion as listed below."
                )
                for test_name in DatasetValidator.additional_tests:
                    with self.create(Itemize()) as itemize:
                        itemize.add_item(test_name)
            with self.create(Subsection("NWB Data")):
                self.append(
                    "Data validation test checks if the "
                    "traces are identical in both NWB and IGOR files."
                )

    def fill_from_dict(self, qc_results):
        """Fill the document using the QC results.

        Args:
            qc_results: dictionary containing the qc results.
        """
        # pylint: disable=too-many-nested-blocks, too-many-branches
        with self.create(Section("Results")):
            # Metadata
            with self.create(Subsection("Failed metadata tests")):
                # Create am inverse dictionary: {failed_test: files_that_failed}
                for nwb_id in qc_results:
                    failed_test = {}
                    for meta_key, meta_val in qc_results[nwb_id]["metadata"].items():
                        if not meta_val:
                            failed_test.setdefault(meta_key, []).append(nwb_id)

                    self.fill_failed_tests(failed_test, nwb_id)

            # Acquisition
            with self.create(Subsection("Failed acquisition tests")):
                for nwb_id in qc_results:
                    failed_test = {}
                    recordings = qc_results[nwb_id]["datasets"]["acquisition"]
                    for rec in recordings:
                        all_test_res = [
                            all(list(val.values())) for val in recordings[rec].values()
                        ]
                        if not all(all_test_res):
                            for test_group in recordings[rec]:
                                for k, v in recordings[rec][test_group].items():
                                    if not v:
                                        failed_test.setdefault(k, []).append(rec)
                                        break
                    self.fill_failed_tests(failed_test, nwb_id)

            # Stimulus
            with self.create(Subsection("Failed stimulus tests")):
                for nwb_id in qc_results:
                    failed_test = {}
                    recordings = qc_results[nwb_id]["datasets"]["stimulus"]
                    for rec in recordings:
                        all_test_res = [
                            all(list(val.values())) for val in recordings[rec].values()
                        ]
                        if not all(all_test_res):
                            for test_group in recordings[rec]:
                                for k, v in recordings[rec][test_group].items():
                                    if not v:
                                        failed_test.setdefault(k, []).append(rec)
                                        break
                    self.fill_failed_tests(failed_test, nwb_id)

    def fill_failed_tests(self, failed_tests, nwb_id):
        """Fill the document with the tests that are failed.

        Args:
            failed_tests (dict): dictionary containing the failed tests for an nwb.
            nwb_id (str): the nwb identifier.
        """
        if failed_tests:
            self.append(bold(f"{nwb_id}"))
            for test_name, files_failed in failed_tests.items():

                chunked_files = utils.chunker(files_failed, 20)
                self.append(f"{test_name}: ")

                for chunk in chunked_files:
                    self.append(" ".join(f for f in chunk) + "\n")
